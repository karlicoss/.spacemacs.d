#!/usr/bin/env python3
'''
This scripts allows triggering opening emacs from a link on a webpage/browser extension via MIME.
To install (register the MIME handler), run

   python3 mimemacs --install

You can check that it works with

   xdg-open 'emacs:/path/to/some/file'

See test_parse_uri for examples.

I haven't found any existing mechanisms for this, please let me know if you know of any!

'''
# TODO make it editor-agnostic? although supporting line numbers will be trickier


# TODO not sure if it should be emacs:// or something?
PROTOCOL = "emacs:"


def test_parse_uri():
    assert parse_uri('emacs:/path/to/file') == (
        '/path/to/file',
        None,
    )

    assert parse_uri('emacs:/path/with spaces') == (
        '/path/with spaces',
        None,
    )

    assert parse_uri('emacs:/path/url%20encoded') == (
        '/path/url encoded',
        None,
    )

    assert parse_uri('emacs:/path/to/file/and/line:10') == (
        '/path/to/file/and/line',
        10,
    )

    import pytest # type: ignore
    with pytest.raises(Exception):
        parse_uri('badmime://whatever')


def test_open_editor():
    from tempfile import TemporaryDirectory
    with TemporaryDirectory() as td:
        p = Path(td) / 'some file.org'
        p.write_text('''
line 1
line 2
line 3 ---- THIS LINE SHOULD BE IN FOCUS!
line 4
'''.strip())
        open_editor(f'emacs:{p}:3')


import argparse
from pathlib import Path
import sys
import subprocess
from subprocess import check_call, run
import tempfile
from urllib.parse import unquote


def error(what) -> None:
    # notify-send used as a user-facing means of error reporting
    run(["notify-send", what])
    raise RuntimeError(what)


def install() -> None:
    this_script = str(Path(__file__).absolute())
    CONTENT = f"""
[Desktop Entry]
Name=Emacs Mime handler
Exec=python3 {this_script} %u
Icon=emacs-icon
Type=Application
Terminal=false
MimeType=x-scheme-handler/emacs;
""".strip()
    with tempfile.TemporaryDirectory() as td:
        pp = Path(td) / 'mimemacs.desktop'
        pp.write_text(CONTENT)
        check_call(['desktop-file-validate', str(pp)])
        check_call([
            'desktop-file-install',
            '--dir', str(Path('~/.local/share/applications').expanduser()),
            '--rebuild-mime-info-cache',
            str(pp),
        ])


from typing import Tuple, Optional
Line = int
File = str
def parse_uri(uri: str) -> Tuple[File, Optional[Line]]:
    if not uri.startswith(PROTOCOL):
        error(f"Unexpected protocol {uri}")

    uri = uri[len(PROTOCOL):]
    spl = uri.split(':')

    linenum: Optional[int] = None
    if len(spl) == 1:
        pass # no lnum specified
    elif len(spl) == 2:
        uri = spl[0]
        # TODO could use that for column number? maybe an overkill though..
        # https://www.gnu.org/software/emacs/manual/html_node/emacs/emacsclient-Options.html
        linenum = int(spl[1])
    else:
        # TODO what if it actually has colons?
        error(f"Extra colons in URI {uri}")
    uri = unquote(uri)
    return (uri, linenum)


def open_editor(uri: str) -> None:
    uri, line = parse_uri(uri)
    if line is None:
        args = [uri]
    else:
        args = [f'+{line}', uri] # emacs specific syntax

    emacs_cmd = [
        'emacsclient',
        '--create-frame',
        # trick to run daemon if it isn't https://www.gnu.org/software/emacs/manual/html_node/emacs/emacsclient-Options.html
        '--alternate-editor=""',
        *args,
    ]
    # todo exec?
    check_call(emacs_cmd)
    return

    ### alternatively, if you prefer a terminal emacs
    emacs_cmd = [
        'emacsclient',
        '--tty',
        '--alternate-editor=""',
        *args,
    ]
    import shlex
    check_call([
        # NOTE: you might need xdg-terminal on some systems
        "x-terminal-emulator",
        "-e",
        ' '.join(map(shlex.quote, emacs_cmd)),
    ])
    ###
   
    

def main():
    p = argparse.ArgumentParser()
    p.add_argument('--install', action='store_true', help='Pass to register MIME in your system')
    p.add_argument('uri', nargs='?')
    p.add_argument('--run-tests', action='store_true', help='Run unit tests')
    args = p.parse_args()
    if args.run_tests:
        # fuck, pytest can't run against a file without .py extension?
        test_parse_uri()
        test_open_editor()
    elif args.install:
        install()
    else:
        open_editor(args.uri)


if __name__ == '__main__':
    main()
